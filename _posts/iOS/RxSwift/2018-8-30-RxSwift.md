# RxSwift

[å®˜æ–¹æ–‡æ¡£](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/)

ps: å­¦ä¹ ç¬”è®°åªæ˜¯éšä¾¿è®°ä¸€è®°ï¼ŒåŠ å¿«å­¦ä¹ é€Ÿåº¦å’Œæ˜ åƒï¼Œæ²¡æœ‰å‚è€ƒæ„ä¹‰ï¼Œå› ä¸ºå…¶å®å®˜æ–¹æ–‡æ¡£çš„æ¯ä¸ªè¡Œéƒ½æ˜¯é‡ç‚¹ã€‚

> TODOsï¼š
  - [âˆš] è¿‡ä¸€éæ–‡æ¡£
  - [x] è¿‡ä¸€éplaygoundå’Œå•å…ƒæµ‹è¯•ç›¸å…³å†…å®¹
  - [x] å­¦ä¹ demoï¼ŒæŠ„ä¸€éå§ï¼Œæ˜ åƒä¼šå¾ˆæ·±åˆ»
  - [x] è¯¦ç»†ç ”ç©¶å†…å®¹ï¼Œå…ˆå‚è€ƒæ–‡æ¡£ï¼Œä¸æ‡‚çš„å†æŸ¥èµ„æ–™
  - [x] åº”ç”¨å®æˆ˜
  - [x] ã€ŠRxSwift Reactive Programming with Swiftã€‹è¿™æœ¬ä¹¦çœŸç¥ï¼Œè§£ç­”ä¸€åˆ‡ç–‘æƒ‘ï¼Œå°¤å…¶æ˜¯å®æˆ˜ä¸Šçš„ï¼Œè¦çœ‹å®Œ

ps: æ²¡æœ‰å®æˆ˜ç ”ç©¶å¤ªæ¯ç‡¥ï¼Œè¿‡ä¸€éæ–‡æ¡£åï¼Œä¼šä¸€è¾¹å®æˆ˜ä¸€è¾¹ç ”ç©¶

## why

Rxæ”¯æŒä»¥å£°æ˜æ–¹å¼æ„å»ºappsã€‚

1. viewå’Œdataç»‘å®š

2. å¤±è´¥é‡è¯•: æ¯”å¦‚ç½‘ç»œè¯·æ±‚å¤±è´¥é‡è¯•;

3. Delegates

4. KVO

5. Notifications

6. Transient state: ä»¥æœç´¢ä¸ºä¾‹ï¼Œç¨‹åºä¸­æœ‰å¾ˆå¤šçš„çŠ¶æ€éœ€è¦å¤„ç†ï¼Œè€ŒRXå¯ä»¥è½»æ¾è§£å†³ï¼Œæ€ä¹ˆè§£å†³çš„è¦æœ‰ç©ºå†çœ‹çœ‹;

7. Compositional disposal: ä»¥åˆ—è¡¨ä¸­çš„cellå›¾ç‰‡æ˜¾ç¤ºä¸ºä¾‹ï¼Œç¨‹åºä¸­æœ‰å¾ˆå¤šç»†èŠ‚å¤„ç†ï¼Œï¼Œè€ŒRXå¯ä»¥è½»æ¾è§£å†³ï¼Œæ€ä¹ˆè§£å†³çš„è¦æœ‰ç©ºå†çœ‹çœ‹;

8. Aggregating network requests: è¯·æ±‚çš„åˆå¹¶;

9. State: å•å‘æ•°æ®æµ?? æ²¡ææ‡‚;

10. Easy integration: æ˜“äºé›†æˆï¼Œä»¥URLSessionä¸ºä¾‹ï¼Œä»‹ç»äº†æ€ä¹ˆè®²è¯·æ±‚è½¬åŒ–Observable 

```swift
extension Reactive where Base: URLSession {
    public func response(request: URLRequest) -> Observable<(Data, HTTPURLResponse)> {
        return Observable.create { observer in
            let task = self.base.dataTask(with: request) { (data, response, error) in
            
                guard let response = response, let data = data else {
                    observer.on(.error(error ?? RxCocoaURLError.unknown))
                    return
                }

                guard let httpResponse = response as? HTTPURLResponse else {
                    observer.on(.error(RxCocoaURLError.nonHTTPResponse(response: response)))
                    return
                }

                observer.on(.next(data, httpResponse))
                observer.on(.completed)
            }

            task.resume()

            return Disposables.create(with: task.cancel)
        }
    }
}
```

11. Benefits

ç®€å•æ¥è¯´ï¼Œä½¿ç”¨Rxå¯ä»¥æ˜¯ä½ çš„ä»£ç ï¼š
- å¯ç»„åˆ <- å› ä¸ºRxæ˜¯ä½œæ›²çš„æ˜µç§°
- å¯é‡å¤ä½¿ç”¨çš„ <- å› ä¸ºå®ƒæ˜¯å¯ç»„åˆçš„
- å£°æ˜æ€§ <- å› ä¸ºå®šä¹‰æ˜¯ä¸å¯å˜çš„ï¼Œåªæœ‰æ•°æ®å‘ç”Ÿå˜åŒ–
- å¯ç†è§£å’Œç®€æ´ <- æé«˜æŠ½è±¡çº§åˆ«å¹¶æ¶ˆé™¤ç¬æ€
- ç¨³å®š <- å› ä¸ºRxä»£ç ç»è¿‡äº†å½»åº•çš„å•å…ƒæµ‹è¯•
- è¾ƒå°‘æœ‰çŠ¶æ€ <- å› ä¸ºæ‚¨å°†åº”ç”¨ç¨‹åºå»ºæ¨¡ä¸ºå•å‘æ•°æ®æµ
- æ²¡æœ‰æ³„æ¼ <- å› ä¸ºèµ„æºç®¡ç†å¾ˆå®¹æ˜“

12. It's not all or nothing

## Getting Started

1. Observables aka Sequences

Every Observable sequence is just a sequence. The key advantage for an Observable vs Swift's Sequence is that it can also receive elements asynchronously.This is the kernel of RxSwift, documentation from here is about ways that we expand on that idea.

- Observable(ObservableType) is equivalent to Sequence
- ObservableType.subscribe method is equivalent to Sequence.makeIterator method.
- Observer (callback) needs to be passed to ObservableType.subscribe method to receive sequence elements instead of calling next() on the returned iterator.


è²Œä¼¼æ˜¯è¯´Observable sequenceå…¶å®å°±æ˜¯sequenceï¼Œåªæ˜¯èƒ½æ¥æ”¶å¼‚æ­¥çš„å…ƒç´ ï¼Œæ‰€ä»¥ä¼šæœ‰ä¸€å †å‡½æ•°å¼çš„æ“ä½œï¼Œæ¯”å¦‚mapï¼Œfilterç­‰ç­‰ï¼›è€Œsubscribeå°±ç›¸å½“äºéå†ã€‚

```swift
enum Event<Element>  {
    case next(Element)      // next element of a sequence
    case error(Swift.Error) // sequence failed with error
    case completed          // sequence terminated successfully
}

class Observable<Element> {
    func subscribe(_ observer: Observer<Element>) -> Disposable
}

protocol ObserverType {
    func on(_ event: Event<Element>)
}
```

2. Disposing

å¦ä¸€ç§æ–¹å¼ç»ˆæ­¢observed sequence

2.1 Dispose Bags

Dispose bags are used to return ARC like behavior to RX.

When a DisposeBag is deallocated, it will call dispose on each of the added disposables.

å¥½åƒæ˜¯è¢«ç”¨äºARCã€‚æ¯”å¦‚ä¸€ä¸ª`ViewController`å¯ä»¥ç”³æ˜å±æ€§`let disposeBag = DisposeBag()`, è¿™æ ·`ViewController`é”€æ¯ï¼Œå¯¼è‡´disposeBagé”€æ¯ï¼Œè¿™æ ·å°±æ¸…ç©ºæ‰€æœ‰çš„observerd sequence

2.2 Take until

Additional way to automatically dispose subscription on dealloc is to use takeUntil operator.

```swift
sequence
    .takeUntil(self.rx.deallocated)
    .subscribe {
        print($0)
    }
```

3. Implicit Observable guarantees

subscribeçš„æ‰§è¡Œè¿‡ç¨‹ä¸ä¼šè¢«ä»»ä½•eventæ‰“æ–­

4. Creating your own Observable (aka observable sequence)

Observableçš„åˆ›å»ºä¸ä¼šæ‰§è¡Œåˆ›å»ºå¤–çš„ä»»ä½•é€»è¾‘ï¼Œç›´åˆ°subscribe

```swift
func searchWikipedia(searchTerm: String) -> Observable<Results> {}

let searchForMe = searchWikipedia("me") // no requests are performed, no work is being done, no URL requests were fired

let cancel = searchForMe
  // sequence generation starts now, URL requests are fired
  .subscribe(onNext: { results in
      print(results)
  })
```

create Observable

```swift
func myJust<E>(_ element: E) -> Observable<E> {
    return Observable.create { observer in
        observer.on(.next(element))
        observer.on(.completed)
        return Disposables.create()
    }
}

myJust(0)
    .subscribe(onNext: { n in
      print(n)
    })
```

5. Creating an Observable that performs work

demo

6. Sharing subscription and share operator

- demo

- shareä¸éshareçš„åŒºåˆ«

shareï¼šæ¯æ¬¡subscribeï¼Œä¼šå…±ç”¨createé—­åŒ…çš„å†…å®¹ï¼Œå³å¤šæ¬¡subscribeï¼Œcreateé—­åŒ…ä¸ä¼šæ‰§è¡Œå¤šæ¬¡
éshareï¼šæ¯æ¬¡subscribeï¼Œéƒ½ä¼šç‹¬ç«‹æ‰§è¡Œcreateé—­åŒ…çš„å†…å®¹ï¼Œå„ä¸å¹²æ‰°

- shareçš„ä½œç”¨ï¼šå¾ˆå¤šobservableï¼Œä¼šbindå¤šæ¬¡ï¼Œæ¯”å¦‚SimpleValidationViewController.swiftä¸­ï¼Œç”¨æˆ·åè¾“å…¥æ¡†çš„æ ¡éªŒï¼Œå³ç»‘å®šå¯†ç æ¡†æ˜¯å¦å¯ä»¥ï¼Œåˆç»‘å®šç”¨æˆ·åæç¤ºæ˜¯å¦æ˜¾ç¤ºï¼Œshareå¯ä»¥å…±ç”¨äº‹ä»¶ï¼Œå®ç°äº‹ä»¶å‘å‡º1æ¬¡ï¼Œå¤šä¸ªobserverç›‘å¬ï¼Œå¹¶å®ç°ä¸šåŠ¡é€»è¾‘ç»‘å®šï¼Œé¿å…æ— æ„ä¹‰çš„æ ¡éªŒäº‹ä»¶å¤šæ¬¡å‘å‡º

subscribe

7. Operators

Rx.playgroundæœ‰æ¼”ç¤ºï¼Œå¦å¤–ï¼ŒRx.playgroundæ˜¯å¾ˆå¥½çš„ä½¿ç”¨playgroundçš„æ¨¡æ¿

7.1 Custom operators

é€šè¿‡demoçœ‹ï¼Œè¿˜è›®ç®€å•

7.2 Life happens

æ²¡çœ‹æ‡‚

8. Playgrounds

9. Error handling

æ²¡çœ‹æ‡‚

10. Debugging Compile Errors

ç¼–è¯‘é”™è¯¯ï¼Œè¯´çš„æ˜¯swiftç±»å‹æ¨æ–­å¶å°”æŠ½é£

11. Debugging

ä»‹ç»äº†ä½¿ç”¨debug operator

11.1 Enabling Debug Mode

è¿™ä¸ªè¦å‚è€ƒä¸€ä¸‹

```ruby
post_install do |installer|
   installer.pods_project.targets.each do |target|
      if target.name == 'RxSwift'
         target.build_configurations.each do |config|
            if config.name == 'Debug'
               config.build_settings['OTHER_SWIFT_FLAGS'] ||= ['-D', 'TRACE_RESOURCES']
            end
         end
      end
   end
end
```

12. Debugging memory leaks

æ²¡çœ‹æ‡‚

13. KVO

13.1 rx.observe

ç›‘å¬strongå±æ€§

13.2 rx.observeWeakly

ç›‘å¬weakå±æ€§

13.3 Observing structs

RxCocoaä»…åšå¥½äº†CGRect, CGSize and CGPointçš„ç›‘å¬

14. UI layer tips

14.1 Threading

å¿…é¡»åœ¨ä¸»çº¿ç¨‹æ›´æ–°UIï¼Œ`observeOn(MainScheduler.instance)`

URLSession extensions don't return result on MainScheduler by default.

14.2 Error

æ²¡çœ‹æ‡‚

14.3 Sharing subscription

æ²¡çœ‹æ‡‚shareæ“ä½œæ—¶é—´å¹²å•¥çš„

15. Making HTTP requests

16. RXDataSources

... is a set of classes that implement fully functional reactive data sources for UITableViews and UICollectionViews.

## Traits (formerly Units)

1. General

Traits are simply a wrapper struct with a single read-only Observable sequence property.

```swift
struct Single<Element> {
    let source: Observable<Element>
}

struct Driver<Element> {
    let source: Observable<Element>
}
...
```

2. RxSwift traits

2.1 Single

A Single is a variation of Observable that, instead of emitting a series of elements, **is always guaranteed to emit either a single element or an error.**

2.2 Completable

A Completable is a variation of Observable that can **only complete or emit an error**. It is guaranteed to not emit any elements.

2.3 Maybe

A Maybe is a variation of Observable that is right in between a Single and a Completable. It can **either emit a single element, complete without emitting an element, or emit an error.**

3. RxCocoa traits

3.1 Driver

version_1:

```swift 
let results = query.rx.text
    .throttle(0.3, scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
    }

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```

version_2:

```swift 
let results = query.rx.text
    .throttle(0.3, scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .observeOn(MainScheduler.instance)  // results are returned on MainScheduler
            .catchErrorJustReturn([])           // in the worst case, errors are handled
    }
    .share(replay: 1)                           // HTTP requests are shared and results replayed
                                                // to all UI elements

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```

version_3:

```swift 
let results = query.rx.text.asDriver()        // This converts a normal sequence into a `Driver` sequence.
    .throttle(0.3, scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .asDriver(onErrorJustReturn: [])  // Builder just needs info about what to return in case of error.
    }

results
    .map { "\($0.count)" }
    .drive(resultCount.rx.text)               // If there is a `drive` method available instead of `bind(to:)`,
    .disposed(by: disposeBag)              // that means that the compiler has proven that all properties
                                              // are satisfied.
results
    .drive(resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```

3.2 Signal 

æ²¡çœ‹æ‡‚

4. ControlProperty / ControlEvent

ä¹Ÿæ²¡çœ‹æ‡‚

## testing

1. Testing custom operators
2. Testing operator compositions (view models, components)

æ¯”è¾ƒçŸ­ï¼Œä¸€å®šè¦ææ‡‚å“¦

## tips

- ä½¿ç”¨çº¯å‡½æ•°
- ä½¿ç”¨å†…ç½®operators
- åˆ›å»ºè‡ªå·±çš„convenience operators
- åˆ›å»ºè‡ªå·±çš„operatorså¯ä»¥ä½¿ç”¨å†…ç½®operators
- Always use operators to compose subscriptions.

1. é¿å…åµŒå¥—subscribe

```swift
textField.rx.text.subscribe(onNext: { text in
    performURLRequest(text).subscribe(onNext: { result in
        ...
    })
    .disposed(by: disposeBag)
})
.disposed(by: disposeBag)
```

2. Preferred way of chaining disposables by using operators. ä½¿ç”¨disposablesæœ€å¥½çš„æ–¹å¼æ˜¯ä½¿ç”¨disposedè¿™ä¸ªoperatorï¼Ÿ

```swift
textField.rx.text
    .flatMapLatest { text in
        // Assuming this doesn't fail and returns result on main scheduler,
        // otherwise `catchError` and `observeOn(MainScheduler.instance)` can be used to
        // correct this.
        return performURLRequest(text)
    }
    ...
    .disposed(by: disposeBag) // only one top most disposable
```

## Math Behind Rx

æ›´æ·±å…¥çš„ä¸œè¥¿

## Hot and Cold Observables

Hot Observables: ä¸ä¾èµ–äºæ˜¯å¦æœ‰subscribedï¼Œæ¯”å¦‚tap coordinates, mouse coordinates, UI control values, current time

Cold Observables: Don't use resources (don't produce heat) until observer subscribes. æ¯”å¦‚Async operations, HTTP Connections, TCP connections, streams

## Comparison with ReactiveCocoa

ä¸çŸ¥æ‰€äº‘

## find compatible

[RxSwiftå…¨å®¶æ¡¶](https://github.com/RxSwiftCommunity)

## References

* [http://reactivex.io/](http://reactivex.io/)
* [Reactive Extensions GitHub (GitHub)](https://github.com/Reactive-Extensions)
* [RxSwift RayWenderlich.com Book](https://store.raywenderlich.com/products/rxswift)
* [Boxue.io RxSwift Online Course](https://boxueio.com/series/rxswift-101) (Chinese ğŸ‡¨ğŸ‡³)
* [Erik Meijer (Wikipedia)](http://en.wikipedia.org/wiki/Erik_Meijer_%28computer_scientist%29)
* [Expert to Expert: Brian Beckman and Erik Meijer - Inside the .NET Reactive Framework (Rx) (video)](https://youtu.be/looJcaeboBY)
* [Reactive Programming Overview (Jafar Husain from Netflix)](https://www.youtube.com/watch?v=dwP1TNXE6fc)
* [Subject/Observer is Dual to Iterator (paper)](http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf)
* [Rx standard sequence operators visualized (visualization tool)](http://rxmarbles.com/)
* [Haskell](https://www.haskell.org/)